package com.client.impl.function.movement;import api.interfaces.EventHandler;import com.client.clickgui.GuiScreen;import com.client.event.events.*;import com.client.system.function.Category;import com.client.system.function.Function;import com.client.system.setting.settings.BooleanSetting;import com.client.system.setting.settings.ListSetting;import com.client.utils.game.movement.MovementUtils;import com.client.utils.math.MsTimer;import com.client.utils.misc.InputUtils;import net.minecraft.client.gui.screen.ChatScreen;import net.minecraft.client.option.KeyBinding;import net.minecraft.client.util.InputUtil;import net.minecraft.network.Packet;import net.minecraft.network.packet.c2s.play.ClickSlotC2SPacket;import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class InvWalk extends Function {    private final ListSetting mode = List().name("Режим").list(List.of("FunTime", "Обычный")).defaultValue("Обычный").build();    public final BooleanSetting guiMove = Boolean().name("Работать в гуи").defaultValue(false).build();    public InvWalk() {        super("Inv Walk", Category.MOVEMENT);    }    private boolean[] move = new boolean[6];    private static final MsTimer stopTimer = new MsTimer();    private final List<ClickSlotC2SPacket> packets = new ArrayList<>();    @Override    public void onEnable() {        move = new boolean[6];    }    @Override    public void onDisable() {        stop();    }    @EventHandler    public void onLeftEvent(GameEvent.Left event) {        move = new boolean[6];    }    @EventHandler    private void onTickEvent(TickEvent.Pre event) {        if (mode.get().equals("FunTime")) {            List<KeyBinding> keyBindings = new ArrayList<>(Arrays.asList(mc.options.keyForward, mc.options.keyJump, mc.options.keyBack, mc.options.keyLeft, mc.options.keyRight, mc.options.keySprint));            if (!stopTimer.passedMs(400)) {                for (KeyBinding keyBinding : keyBindings) keyBinding.setPressed(false);                return;            }            for (KeyBinding keyBinding : keyBindings) {                keyBinding.setPressed(InputUtil.isKeyPressed(mc.getWindow().getHandle(), keyBinding.getDefaultKey().getCode()));            }        } else if (shouldWork()) {            mc.options.keyForward.setPressed(move[0]);            mc.options.keyBack.setPressed(move[1]);            mc.options.keyLeft.setPressed(move[2]);            mc.options.keyRight.setPressed(move[3]);            mc.options.keyJump.setPressed(move[4]);            mc.options.keySprint.setPressed(move[5]);        }    }    @EventHandler    public void onClose(CloseScreenEvent e) {        if (mode.get().equals("FunTime") && !packets.isEmpty() && MovementUtils.isMoving()) {            new Thread(() -> {                stopTimer.reset();                try {                    Thread.sleep(400);                } catch (InterruptedException ex) {                    throw new RuntimeException(ex);                }                for (Packet<?> packet : packets) mc.player.networkHandler.sendPacket(packet);                packets.clear();            }).start();        }    }    @EventHandler    public void onPacket(PacketEvent.Send e) {        if (mode.get().equals("FunTime")) {            if (e.packet instanceof ClickSlotC2SPacket p && MovementUtils.isMoving()) {                packets.add(p);                e.cancel();            }        }    }    @EventHandler    private void onKeyEvent(KeyEvent event) {        if (!mode.get().equals("FunTime")) {            int key = event.key;            if (event.action == InputUtils.Action.PRESS || event.action == InputUtils.Action.REPEAT) {                if (key == mc.options.keyForward.getDefaultKey().getCode()) move[0] = true;                if (key == mc.options.keyBack.getDefaultKey().getCode()) move[1] = true;                if (key == mc.options.keyLeft.getDefaultKey().getCode()) move[2] = true;                if (key == mc.options.keyRight.getDefaultKey().getCode()) move[3] = true;                if (key == mc.options.keyJump.getDefaultKey().getCode()) move[4] = true;                if (key == mc.options.keySprint.getDefaultKey().getCode()) move[5] = true;            }            if (event.action == InputUtils.Action.RELEASE) {                if (key == mc.options.keyForward.getDefaultKey().getCode()) move[0] = false;                if (key == mc.options.keyBack.getDefaultKey().getCode()) move[1] = false;                if (key == mc.options.keyLeft.getDefaultKey().getCode()) move[2] = false;                if (key == mc.options.keyRight.getDefaultKey().getCode()) move[3] = false;                if (key == mc.options.keyJump.getDefaultKey().getCode()) move[4] = false;                if (key == mc.options.keySprint.getDefaultKey().getCode()) move[5] = false;            }        }    }    private boolean shouldWork() {        if (mc.currentScreen == null || mc.currentScreen instanceof ChatScreen) return false;        return guiMove.get() || !(mc.currentScreen instanceof GuiScreen);    }    private void stop() {        mc.options.keyForward.setPressed(false);        mc.options.keyLeft.setPressed(false);        mc.options.keyBack.setPressed(false);        mc.options.keyRight.setPressed(false);        mc.options.keyJump.setPressed(false);        mc.options.keySprint.setPressed(false);        mc.options.keySneak.setPressed(false);    }}